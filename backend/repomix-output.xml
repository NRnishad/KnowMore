This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
package.json
src/application/IOtpRepository.ts
src/application/repositories/IOtpRepository.ts
src/application/repositories/IUserRepository.ts
src/application/use-cases/user/getUserData.ts
src/application/use-cases/user/registerUser.ts
src/application/use-cases/user/sendOtp.ts
src/application/use-cases/user/verifyOtp.ts
src/domain/models/Otp.ts
src/domain/models/User.ts
src/infrastructure/config/config.ts
src/infrastructure/repositories/dbConnection.ts
src/infrastructure/repositories/OtpRepository.ts
src/infrastructure/repositories/userRepositoryImpl.ts
src/infrastructure/services/emailService.ts
src/infrastructure/services/hashService.ts
src/infrastructure/services/otpService.ts
src/interfaces/controllers/authController.ts
src/interfaces/middlewares/errorMiddleWare.ts
src/interfaces/routes/authRoutes.ts
src/main/server.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "build": "tsc",
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "ts-node-dev --respawn --transpile-only src/main/server.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@types/express-session": "^1.18.0",
    "@types/multer": "^1.4.12",
    "@types/passport": "^1.0.17",
    "@types/passport-google-oauth20": "^2.0.16",
    "@types/streamifier": "^0.1.2",
    "axios": "^1.7.7",
    "bcryptjs": "^2.4.3",
    "cloudinary": "^1.41.3",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.21.1",
    "express-session": "^1.18.1",
    "google-auth-library": "^9.15.0",
    "ioredis": "^5.4.1",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.8.1",
    "multer": "^1.4.5-lts.1",
    "multer-storage-cloudinary": "^4.0.0",
    "nodemailer": "^6.9.16",
    "passport": "^0.7.0",
    "passport-google-oauth20": "^2.0.0",
    "socket.io": "^4.8.1",
    "streamifier": "^0.1.1",
    "stripe": "^17.5.0",
    "ts-node-dev": "^2.0.0"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cookie-parser": "^1.4.7",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/node": "^22.9.0",
    "@types/nodemailer": "^6.4.16",
    "nodemon": "^3.1.7",
    "typescript": "^5.6.3"
  }
}
</file>

<file path="src/application/IOtpRepository.ts">
export interface IOtpRepository {
    generateOtp(email: string, otp: string, expiresAt: Date): Promise<void>
    verifyOtp(email: string, otp: string): Promise<boolean>
}
</file>

<file path="src/application/repositories/IOtpRepository.ts">
export interface IOtpRepository {
    generateOtp(email: string, otp: string, expiresAt: Date): Promise<void>
    verifyOtp(email: string, otp: string): Promise<boolean>
}
</file>

<file path="src/application/repositories/IUserRepository.ts">
import { IUser } from "../../domain/models/User";

export interface IUserRepository{
    findById(userId: string) : Promise<IUser | null>;
    findByIdWithPassword(userId: string): Promise<IUser | null>
    updatePassword(userId: string, newPassword: string):Promise<IUser | null>
    findEmailAlreadyExists (email: string, userid: string) : Promise<boolean> 
    update(user: Partial<IUser>):Promise<IUser | null>
    approveUserSignupVerification(email: string):Promise<boolean>
    deleteUser(userId: string):Promise<boolean>
    //login
    getUserByEmail(email: string): Promise<IUser | null>

    //signup 
    createUser(user:Partial<IUser>) : Promise<IUser>
    
    save(user:IUser) : Promise<IUser>
    
   
   }
</file>

<file path="src/application/use-cases/user/getUserData.ts">
import { CustomError } from "../../../interfaces/middlewares/errorMiddleWare"
import { IUserRepository } from "../../repositories/IUserRepository"


export class GetUserDataUseCase {
    constructor(private userRepo : IUserRepository) {}

    async execute(userId : string) {
        const userdata = await this.userRepo.findById(userId)
    if(!userdata) {
        throw new CustomError('user not found', 400)
    }

    return userdata
    }
}
</file>

<file path="src/application/use-cases/user/registerUser.ts">
import bcrypt from 'bcryptjs'
import User, {IUser} from '../../../domain/models/User'
import { CustomError } from '../../../interfaces/middlewares/errorMiddleWare';
import { IUserRepository } from '../../repositories/IUserRepository';
import { hashPassword } from '../../../infrastructure/services/hashService';



export class RegisterUserUseCase{
    constructor(private userRepository: IUserRepository){}

    async execute(userData: {firstName: string, lastName: string, email: string, phone: string, password: string}) {
        const {firstName , lastName, email, password, phone} = userData;
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

        if(!emailRegex.test(email)){
            throw new CustomError('Enter a valid email', 400)
        }
         //check user already exists or not 
    const userExist = await this.userRepository.getUserByEmail(email)
    if(userExist && userExist.isVerified === false){
        throw new CustomError('Please verify your account',400)
    }
    if(userExist){
        throw new CustomError('User already exists', 400)
    }
    if(!password){
        throw new CustomError('password required', 400)
    }

    const hashedPassword = await hashPassword(password)
    const registeredUser = await this.userRepository.createUser({firstName, lastName, email, role : 'student', password: hashedPassword, phone})
     return registeredUser
    }
}
</file>

<file path="src/application/use-cases/user/sendOtp.ts">
import { generateOtp } from "../../../infrastructure/services/otpService";
import { sendEmail } from "../../../infrastructure/services/emailService";


export const sendOtp = async (email : string) => {
    const otpCode = await generateOtp(email);
    console.log('send otp to email')
    // await sendEmail(email, 'Your OTP code', `Your OTP code is : ${otpCode}`);
    await sendEmail(email, 'Your OTP code', 
        
`Subject: Your OTP Verification Code


Thank you for signing up with us. To verify your email, please enter the following

One Time Password (OTP): ${otpCode}

This OTP is valid for 10 minutes from the receipt of this email.

Best regards,
knowMore.`
);
    console.log('otp sent successfully', otpCode)
    return {message : 'OTP sent successfully' , otpCode}
}
</file>

<file path="src/application/use-cases/user/verifyOtp.ts">
import { verifyOtp } from "../../../infrastructure/services/otpService";
import { CustomError } from "../../../interfaces/middlewares/errorMiddleWare";
import { UserRepositoryImpl } from "../../../infrastructure/repositories/userRepositoryImpl";

const userRepository = new UserRepositoryImpl()
export const verifyOtpCode = async (email : string, otp : string) => {
    const isValid = await verifyOtp(email, otp);
    if(!isValid) throw new CustomError("Invalid or expired OTP" , 400)
        
        //update user verification status
        const verificationStatus = await userRepository.approveUserSignupVerification(email);
        if(!verificationStatus){
            throw new CustomError('Verification failed', 400)
        }
        
    return {message : 'OTP verified successfully'}
}
</file>

<file path="src/domain/models/Otp.ts">
import mongoose ,{Document, Schema} from "mongoose";

export interface IOtp extends Document{
    email : string;
    otp : string;
    expiresAt : Date;
}

const OtpSchema : Schema = new Schema({
    email : {type: String, required : true},
    otp : {type : String, required: true},
    expiresAt : {type : Date, required : true}
});

export default mongoose.model<IOtp>('Otp', OtpSchema)
</file>

<file path="src/domain/models/User.ts">
import mongoose, { Document, Schema} from "mongoose";

export interface IUser extends Document {
    firstName : string;
    lastName : string;
    password?: string;
    email : string;
    role : string;
    isVerified: boolean;
    profileImageUrl? : string,
    profileImagePublicId?:string,
    status: string,
    phone: string,
    googleId : string,
    _id: string,
    createdAt: Date;
    updatedAt: Date;
}

const UserSchema : Schema = new Schema({
    firstName  : {type: String, required : true},
    lastName : {type : String, required : true},
    email : {type: String, required : true, unique :true},
    phone : {type: String,},
    password : {type : String, },
    role : {type: String , enum : ['admin', 'student', 'instructor'], default : 'student'} ,
    isVerified : {type :Boolean, default: false},
    status : {type:String, enum: ['active', 'inactive'], default: 'active'},
    googleId : {type: String},
    profileImageUrl : {type: String},
    profileImagePublicId : {type: String},
},{timestamps: true});


export default mongoose.model<IUser>('User', UserSchema);
</file>

<file path="src/infrastructure/config/config.ts">
import dotenv from 'dotenv'
dotenv.config()

export interface AppConfig {
    ENVIRONMENT : string;
    PORT : string | number;
}

export interface CorsConfig {
    CLIENT_URL : string;
    ALLOWED_HEADERS : string[];
    ALLOWED_METHODS : string[];
    CREDENTIALS : boolean
}

export interface MongoDBConfig {
    URI: string | undefined;
}

export interface JwtConfig {
    ACCESS_TOKEN_SECRET: string;
    REFRESH_TOKEN_SECRET: string;
    ACCESS_TOKEN_EXPIRE?: string;
    REFRESH_TOKEN_EXPIRE?: string;
}

export interface GoogleConfig {
    GOOGLE_CLIENT_ID?: string;
    GOOGLE_CLIENT_SECRET?: string;
    GOOGLE_CALLBACK_URL?: string;
}

export interface EmailConfig {
    EMAIL_USER?: string;
    EMAIL_PASS?: string;
}

export interface SessionConfig {
    SESSION_SECRET?: string;
}

export interface CloudinaryConfig {
    CLOUD_NAME?: string,
    API_KEY?: string,
    API_SECRET?: string
}
export interface StripeConfig {
    STRIPE_PUBLISHABLE_KEY? : string,
    STRIPE_SECRET_KEY ?:string,
    STRIPE_WEBHOOK_SECRET?: string
}

export interface Config {
    app: AppConfig;
    cors: CorsConfig;
    mongoDB: MongoDBConfig;
    jwt: JwtConfig;
    google: GoogleConfig;
    email: EmailConfig;
    session: SessionConfig;
    cloudinary : CloudinaryConfig;
    stripe: StripeConfig
}


export const config : Config = {
    app: {
        ENVIRONMENT: process.env.NODE_ENV || 'development',
        PORT: process.env.PORT || '5000',

    },
    cors: {
        CLIENT_URL: process.env.CLIENT_URL || "http://localhost:5173",
        ALLOWED_HEADERS : ['Content-Type', 'Authorization'],
        ALLOWED_METHODS : ["GET", "POST", "DELETE", "PUT","PATCH"],
        CREDENTIALS : true,
    },

    mongoDB: {
        URI : process.env.MONGO_URI 
    },

    jwt: {
        ACCESS_TOKEN_SECRET : process.env.ACCESS_TOKEN_SECRET || 'access secret',
        REFRESH_TOKEN_SECRET : process.env.REFRESH_TOKEN_SECRET || 'refresh secret',
        ACCESS_TOKEN_EXPIRE : process.env.ACCESS_TOKEN_EXPIRE,
        REFRESH_TOKEN_EXPIRE : process.env.REFRESH_TOKEN_EXPIRE,
    },
    google: {
        GOOGLE_CLIENT_ID : process.env.GOOGLE_CLIENT_ID,
        GOOGLE_CLIENT_SECRET : process.env.GOOGLE_CLIENT_SECRET,
        GOOGLE_CALLBACK_URL : process.env.GOOGLE_CALLBACK_URL
    },
    email: {
        EMAIL_USER: process.env.EMAIL_USER,
        EMAIL_PASS : process.env.EMAIL_PASS
    },

    session: {
        SESSION_SECRET : process.env.SESSION_SECRET
    },

    cloudinary:{
        CLOUD_NAME: process.env.CLOUDINARY_CLOUD_NAME,
        API_KEY : process.env.CLOUDINARY_API_KEY,
        API_SECRET : process.env.CLOUDINARY_API_SECRET
    },
    stripe : {
        STRIPE_PUBLISHABLE_KEY: process.env.STRIPE_PUBLISHABLE_KEY,
        STRIPE_SECRET_KEY : process.env.STRIPE_SECRET_KEY,
        STRIPE_WEBHOOK_SECRET : process.env.STRIPE_WEBHOOK_SECRET
    }
}
</file>

<file path="src/infrastructure/repositories/dbConnection.ts">
import mongoose from "mongoose";

export const connectDB = async () => {
    try {
        await mongoose.connect(process.env.MONGO_URI as string)
        console.log("MongoDB connected successfully")
    } catch (error) {
        console.error('Database connection error', error);
        process.exit(1)
    }
}
</file>

<file path="src/infrastructure/repositories/OtpRepository.ts">
import { IOtpRepository } from "../../application/repositories/IOtpRepository";
import Otp from "../../domain/models/Otp";

export class OtpRepository implements IOtpRepository{
    async generateOtp(email: string, otp: string, expiresAt: Date): Promise<void> {
        await Otp.deleteMany({email}) //remove existing otp for the email
        await Otp.create({email, otp, expiresAt})
    }

    async verifyOtp(email: string, otp: string): Promise<boolean> {
        const otpRecord = await Otp.findOne({email, otp, expiresAt: { $gte: new Date()}})
        return !! otpRecord;
    }
}
</file>

<file path="src/infrastructure/repositories/userRepositoryImpl.ts">
import { IUserRepository } from "../../application/repositories/IUserRepository";
import User, {IUser} from "../../domain/models/User";


export class UserRepositoryImpl implements IUserRepository {
    async findById(userId: string): Promise<IUser | null> {
        return User.findById(userId).select('-password')
    }

    async findByIdWithPassword(userId: string): Promise<IUser | null> {
        return User.findById(userId)
    }

    async approveUserSignupVerification(email: string):Promise<boolean>{
        const updatedUser = await User.updateOne({email}, {isVerified: true})
         // Check if the user was found and updated
    if (updatedUser.matchedCount > 0 && updatedUser.modifiedCount > 0) {
        return true;
    }
    return false; 
    }

    async findEmailAlreadyExists (email: string, userid: string) : Promise<boolean> {
        const findUser = await User.findOne({ email: email, _id: {$ne: userid}})
        return findUser ? true : false;
    }

    async updatePassword(userId: string, newPassword: string):Promise<IUser | null> {
        try {
            const updatedUser = await User.findByIdAndUpdate(userId, 
                { password: newPassword},
                {new : true, runValidators: true}
            ).select('-password');

            return updatedUser;
        } catch (error) {
            throw error
        }
    }

    async update(user: Partial<IUser>):Promise<IUser | null> {
        const {_id, ...rest} = user
        const updated = await User.findByIdAndUpdate(_id, {...rest}, {new: true, runValidators: true}).select('-password')
        return updated;
    }
    async save(user:IUser): Promise<IUser> {
        return user.save();
    }

    //signup 
    async createUser(user:Partial<IUser>) : Promise<IUser> {
        const newUser = new User(user);
        return await newUser.save(); 
        
    }

    //login
    async getUserByEmail(email: string): Promise<IUser | null> {
        return await User.findOne({email})
    }
    async getAllUsersExcluded(userId:string): Promise<IUser[]> {
        return await User.find({_id:{$ne: userId}  ,isVerified: true, status : 'active', role:{$ne:'admin'}}).select('-password -googleId -profileImagePublicId')
    }
    async getAllUsers():Promise<IUser[]> {
        return await User.find()
    }

    async getAllInstructorsListForUser(userId: string): Promise<IUser[]> {
        return await User.find({_id:{$ne: userId}  ,isVerified: true, status : 'active', role:{$eq:'instructor'}}).select('-password -googleId -profileImagePublicId')
    }

    async countAll(): Promise<number> {
        return await User.countDocuments();
    }

    async countByStatus(status: string): Promise<number> {
        return await User.countDocuments({status})
    }

    async countByRole(): Promise<{ student: number; instructor: number; admin: number; }> {
        const roles:{_id:string, count:number}[] = await User.aggregate([
            {$match: { isVerified: true, status: 'active'}},
            {$group: {_id: "$role", count:{ $sum: 1}}}
        ])
        const roleCounts = {student: 0, instructor:0, admin: 0};
        roles.forEach((role:{_id:string, count:number}) => {
            const key = role._id as 'student' | 'instructor' | 'admin'
            roleCounts[key] = role.count;
        })
        return roleCounts;
    }
    async getRegistrationsOverTime(timeFrame: 'daily' | 'weekly' | 'monthly' | 'yearly'): Promise<{ date: string; count: number; }[]> {
        const groupStage = {
            daily: {
                $dateToString: { format : "%Y-%m-%d", date: "$createdAt"},
            },
            weekly: {
                $dateToString: { format : "%Y-%U", date: "$createdAt"},
            },
            monthly: {
                $dateToString: { format : "%Y-%m", date: "$createdAt"},
            },
            yearly: {
                $dateToString: { format : "%Y", date: "$createdAt"},
            },
        }
        const results = await User.aggregate([
            {$group : { 
                _id: groupStage[timeFrame] ,
                 count: {$sum:1}}},
            { $sort : { _id: 1 }},
        ])
        return results.map(result => {
            let formattedDate = result._id;

            if(timeFrame === 'weekly') {
                const [year, week] = formattedDate.split('-');
                formattedDate = `Week ${parseInt(week)}, ${year}`;
            }
            return {
                date: formattedDate,
                count: result.count
            }
        })
    }

    

    async deleteUser(userId: string):Promise<boolean> {
        const result = await User.findByIdAndDelete(userId);
        return result ? true : false;
    }

   
}
</file>

<file path="src/infrastructure/services/emailService.ts">
import nodemailer from 'nodemailer';

export const sendEmail = async (to:string, subject : string, text : string) => {
    console.log('sendEmail service hit', to)
    const transporter = nodemailer.createTransport({
        service : 'Gmail',
        auth:{
            user : process.env.EMAIL_USER,
            pass : process.env.EMAIL_PASS   
        },
            tls: {
              rejectUnauthorized: false, // Ignore SSL certificate errors
            },
    })

    await transporter.sendMail({from : process.env.EMAIL_USER, to , subject, text})
    console.log('email sent')
}
</file>

<file path="src/infrastructure/services/hashService.ts">
import bcrypt from 'bcryptjs';

export const hashPassword = async (password : string): Promise<string> =>{
    const salt = await bcrypt.genSalt(10);
    return bcrypt.hash(password, salt)
};

export const comparePassword = async (password : string, hashed:string) : Promise<boolean> => {
    return bcrypt.compare(password, hashed)
}
</file>

<file path="src/infrastructure/services/otpService.ts">
import { randomInt } from "crypto";
import { OtpRepository } from "../repositories/OtpRepository";

const otpRepository = new OtpRepository()
export const generateOtp = async (email: string): Promise<string> => {
    try {
        const otp = randomInt(1000, 9999).toString();
        const expiresAt = new Date(Date.now() + 10 * 60 * 1000);
        await otpRepository.generateOtp(email, otp, expiresAt);
        return otp;
      } catch (error) {
        console.error("Error generating OTP:", error);
        throw new Error("Failed to generate OTP");
      }
}

export const verifyOtp = async (email : string, otp: string): Promise <boolean> => {
   return await otpRepository.verifyOtp(email, otp)
}
</file>

<file path="src/interfaces/controllers/authController.ts">
import { NextFunction, Request, Response } from "express";
import { RegisterUserUseCase } from "../../application/use-cases/user/registerUser";
import { verifyOtpCode } from "../../application/use-cases/user/verifyOtp";
import { sendOtp } from "../../application/use-cases/user/sendOtp";
import { CustomError } from "../middlewares/errorMiddleWare";
import { GetUserDataUseCase } from "../../application/use-cases/user/getUserData";
import { UserRepositoryImpl } from "../../infrastructure/repositories/userRepositoryImpl";


const userRepository = new UserRepositoryImpl();

export const signUp = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { firstName, lastName, email, password, phone } = req.body;
    const registerUserUseCase = new RegisterUserUseCase(userRepository);
    const registeredUser = await registerUserUseCase.execute({
      firstName,
      lastName,
      email,
      password,
      phone,
    });
    const { password: removedPassword, ...rest } = registeredUser.toObject();
    //send otp
    const sentOTP = await sendOtp(registeredUser.email);
    res.status(201).json({ success: true, user: rest });
  } catch (error: any) {
    next(error);
  }
};

export const sendOtpHandler = async (req: Request, res: Response) => {
  try {
    const { email } = req.body;
    //sent otp
    const sentOTP = await sendOtp(email);
    console.log("sentOtp controller", sentOTP);
    res.status(200).json(sentOTP);
  } catch (error: any) {
    res.status(400).json({ error: error.message });
    console.error(error.message);
  }
};

export const verifyOtpHandler = async (req: Request, res: Response) => {
  try {
    const { email, otp } = req.body;;
    const response = await verifyOtpCode(email, otp);
    res.status(200).json(response);
  } catch (error: any) {
    res.status(400).json({ success: false, message: error.message });
    console.error(error);
  }
};

export const getUserDataController = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { userId } = req.params;
    if (!userId) {
      throw new CustomError("User id not found", 400);
    }
    const getUserDataUseCase = new GetUserDataUseCase(userRepository);
    const response = await getUserDataUseCase.execute(userId);
    res
      .status(200)
      .json({
        success: true,
        user: response,
        message: "User data sent to front end",
      });
  } catch (error: any) {
    next(error);
  }
};
</file>

<file path="src/interfaces/middlewares/errorMiddleWare.ts">
import { Request, Response, NextFunction } from "express";

class CustomError extends Error{
    statusCode : number;
    constructor(message : string, statusCode : number = 500){
        super(message);
        this.statusCode = statusCode;
        Error.captureStackTrace(this, this.constructor)
    }
}

//middleware handler

const errorMiddleWare = (
    err: Error | CustomError,
    req : Request,
    res : Response,
    next : NextFunction
) => {
    console.error(`[ERROR] ${err.message}`)

    const statusCode = (err as CustomError).statusCode || 500;
    const message  = err.message || 'Internal Server Error';

    res.status(statusCode).json({
        success : false,
        message
    })
}

export {CustomError, errorMiddleWare};
</file>

<file path="src/interfaces/routes/authRoutes.ts">
import { Request, Response, Router } from "express";
import { signUp , sendOtpHandler, verifyOtpHandler,  } from "../controllers/authController";

const router = Router();
router.post('/signup', signUp);
router.post('/send-otp', sendOtpHandler)
router.post('/verify-otp', verifyOtpHandler)
export default router;
</file>

<file path="src/main/server.ts">
import express, { NextFunction, Request, Response } from 'express';
import dotenv from 'dotenv';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import { connectDB } from '../infrastructure/repositories/dbConnection';
import authRoutes from '../interfaces/routes/authRoutes'
import bodyParser from 'body-parser'
import { errorMiddleWare } from '../interfaces/middlewares/errorMiddleWare';
import session from 'express-session';
import { config } from '../infrastructure/config/config';

import { createServer } from 'http';


const PORT = config.app.PORT
const app = express();

//create an HTTP server for socket 
const server = createServer(app);


app.use(express.json());
dotenv.config();
//cookie parser 
app.use(cookieParser());

//CORS setup 
app.use(cors({
    origin : config.cors.CLIENT_URL,
    allowedHeaders : config.cors.ALLOWED_HEADERS,
    methods : config.cors.ALLOWED_METHODS,
    credentials : config.cors.CREDENTIALS
}));


app.use(bodyParser.urlencoded({
    extended: true
  }));

//middleware for sessions
app.use(
    session({
        secret: process.env.SESSION_SECRET as string,
        resave: false,
        saveUninitialized: false,
        cookie: { secure: process.env.NODE_ENV === 'development' }
    })
);


//api test
app.get('/', (req: Request , res:Response, next : NextFunction) => {
    res.status(200).json({
        success :true,
        message : 'API is working'
    })
})

//authroutes 
app.use('/api/auth', authRoutes)


//unknown routes 
app.all('*', (req: Request, res: Response, next : NextFunction) => {
    const err = new Error(`Route ${req.originalUrl} not found`) as any;
    err.statusCode = 404;
    next(err)
})


//error middleware (this must be last middleware)
app.use(errorMiddleWare)

//create server 
server.listen(PORT, () => {
    console.log(`server is running on port : http://localhost:${PORT}'`)
    connectDB();
});
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "ES6",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    "rootDir": "./src",                                  /* Specify the root folder within your source files. */
    // "moduleResolution": "node10",                     /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */
    // "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */
    // "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
    // "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
    // "noUncheckedSideEffectImports": true,             /* Check side effect imports. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    "outDir": "./dist",                                   /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */
    // "isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */

    /* Type Checking */
    "strict": true,                                      /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "strictBuiltinIteratorReturn": true,              /* Built-in iterators are instantiated with a 'TReturn' type of 'undefined' instead of 'any'. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true,                                 /* Skip type checking all .d.ts files. */
    
  },
  
  "include": ["src/**/*", "src/types/express.d.ts"]
  

  
}
</file>

</files>
